# 知识点列表

| 编号 | 名称          | 描述                                  | 级别 |
| ---- | ------------- | ------------------------------------- | ---- |
| 1    | File 类       | 操作文件 / 目录路径（不处理文件内容） | **   |
| 2    | IO 流核心概念 | 输入输出流的定义、分类及核心思想      | **   |
| 3    | 字节流        | 以字节为单位读写数据（万能流）        | **   |
| 4    | 字符流        | 以字符为单位读写数据（适合文本）      | **   |
| 5    | IO 流使用规范 | 创建→读写→关闭（资源释放）            | **   |
| 6    | 缓冲区优化    | 字节 / 字符数组提升 IO 效率           | **   |

# 文件系统（File 类）



## 1.File类的核心概念

File 类位于`java.io`包下，是对文件系统中**文件 / 目录路径**的抽象表示（而非文件内容本身）。它的核心作用是：创建 / 删除文件 / 目录、判断文件 / 目录状态、获取文件属性（大小、路径）、遍历目录文件等。

- java.io.File 用于表示文件（目录），也就是说程序员可以通过File类在程序中操作硬盘上的文件和 目录。  
- File 类只用于表示文件（目录）的信息（名称、大小等），丌能对文件的内容进行访问。 



## 2. File类的核心结构

- 核心属性：底层封装路径字符串（无公开成员变量）
- 核心方法分类：
  - 路径相关：`getPath()`（相对路径）、`getAbsolutePath()`（绝对路径）、`getName()`（文件名）
  - 创建删除：`createNewFile()`（创建文件）、`mkdir()`（单级目录）、`mkdirs()`（多级目录）、`delete()`（删除文件 / 空目录）
  - 状态判断：`exists()`（是否存在）、`isFile()`（是否文件）、`isDirectory()`（是否目录）
  - 目录遍历：`list()`（文件名数组）、`listFiles()`（File 对象数组）



## 3.File类的语法格式

### 3.1 语法格式（创建 File 对象）

```java
// 方式1：直接传入完整路径
File file1 = new File("D:/test.txt");
// 方式2：父路径 + 子路径
File file2 = new File("D:/", "test.txt");
// 方式3：父File对象 + 子路径
File parentDir = new File("D:/");
File file3 = new File(parentDir, "test.txt");
```



## 4. File类的常用操作 

### 案例： File类的常用操作 

```java
import java.io.File;
import java.io.IOException;

public class FileDemo {
    public static void main(String[] args) {
        // 1. 指向目标文件
        File file = new File("./demo/test.txt");
        
        try {
            // 2. 判断文件是否存在，不存在则创建
            if (!file.exists()) {
                boolean isCreated = file.createNewFile();
                System.out.println("文件创建结果：" + isCreated);
            }
            
            // 3. 获取文件属性
            System.out.println("文件名称：" + file.getName());
            System.out.println("相对路径："+file.getPath());
            System.out.println("绝对路径：" + file.getAbsolutePath());
            System.out.println("文件大小（字节）：" + file.length());
            System.out.println("是否是文件：" + file.isFile());
            
            // 4. 创建多级目录
            File multiDir = new File("./demo/testDir/subDir1/subDir2");
            boolean dirCreated = multiDir.mkdirs(); // mkdirs支持多级创建
            System.out.println("多级目录创建结果：" + dirCreated);
            
        } catch (IOException e) {
            e.printStackTrace(); // 捕获文件创建异常
        }
    }
}
```

第一次运行结果：

```tex
文件创建结果：true
文件名称：test.txt
相对路径：.\demo\test.txt
绝对路径：D:\Develop\Project\javase\.\demo\test.txt
文件大小（字节）：0
是否是文件：true
多级目录创建结果：true
```



## 5.java.io.File 基本 API 

File 代表文件系统中对文件/目录的管理操作（增删改查，CRUD）

常用API方法： 

- File(String)                                     指定文件名的构造器

- long length()                                 文件的长度 

- long lastModified()  

- String getName()  

- String getPath()  

- boolean exists()  

- boolean dir.isFile()  

- boolean dir.isDirectory()  

- boolean mkdir()  

- boolean mkdirs()  

- boolean delete();  

- boolean createNewFile() throw IOException  

- File[] listFile()

### 示例1：File API 方法演示
```
任务:
A 检查当前文件夹中是否包含目录 demo
B如果没有demo，就创建文件夹demo
C在demo 中创建文件 test.txt
D显示demo 文件夹的内容.
E显示test.txt 的绝对路径名
F显示test.txt 的文件长度和创建时间
```
FileDemo:

```
```



## 6.回调模式和FileFilter 

FileFilter 类是对操作文件的过滤，相当于命令：ls|grep patten 

API方法：File[] listFile(FileFilter)

### 示例1:列出指定目录下所有的.java文件 

```任务：
有条件列目录
列出指定目录的.java文件
如：列出 src/corejava/day07 中的.java文件
```

FileFilterDemo:

```java
```

注： 

- **listFiles()**方法会将dir 中每个文件交给**accept()**方法检测，如果返回true，就作为方法的返 回结果元素 

- **增强循环（for each循环）**：JDK5提供的简化版for循环 
  -  实现原理基本相同，表现形式更简洁  

- **回调模式**  
  - accept()方法的调用属于回调模式



## 7.RandomAccessFile 

RandomAccessFile 类是Java 提供的功能丰富的文件内容访问类，它提供了众多方法来访问文件 内容，既可以读取文件内容，也可以向文件输出数据，RandomAccessFile支持“随机访问”方式，可 以访问文件的任意位置。 

7.1 Java 文件模型 

在硬盘上文件是byte by byte存储的，是数据的集合 

7.2 打开文件 

有两种模式 "rw"（读写）、"r"（只读）  
RandomAccessFile raf = new RandomAccessFile(file, "rw");  
打开文件时候默认文件指针在开头 pointer=0 

7.3 写入方法 

raf.write(int)可以将整数的“低八位”写入到文件中，同时指针自劢移劢到下一个位置, 准备 再次写入  

- 注意：文件名的扩展名要明确指定, 没有默认扩展名现象！  

  `RandomAccessFile raf = new RandomAccessFile("Hello.java", "rw"); `

7.4 读取文件

int b = raf.read() 从文件中读取一个byte(8位) 填充到int的低八位, 高24位为0, 返回值 范围正数: 0~255, 如果返回-1表示读取到了文件末尾! 每次读取后自劢移劢文件指针, 准备 下次读取。 

7.5 文件读写完成以后一定关闭文件 

Sun官方说明，如果不关闭，可能遇到一些意想不到的错误，根据具体操作平台不同会有不同。 在使用过程中，切忌文件读写完成后要关闭文件。 

### 写入方法

#### 案例1:RandomAccessFile 演示_写入文件 

```tex
/**	随机文件读写演示
*	任务:
*	A 在demo文件夹中创建raf.dat
*	B打开这个文件
*	C写人'A'和'B
*	D写入整数 0x7fffffff(int类型最大值)
*	E写入GBK 编码的'中'，d6d0
*	F一次性读取文件内容
*
*	文件模型：
*	data(下标)
*	index(下标)
*	pointer(游标)
*/
```

RAFWriteDemo:

```java
```

注：  

- raf.write( 'A' )的**写入过程**：  

  首先，字符A在内存中是16位无符号整数0000 0000 0000 0041  

  其次，自劢类型转换，转为int类型0000 0000 0000 0000 0000 0000 0000 0041  

  最后，截取高8位，将低8位的数据写入“**流**”中 0000 0041



###  读取文件 

#### 案例2:RandomAccessFile 演示_读取文件 

```tex
/**文件读取操作
*	任务:
*	A 只读打开文件，移动到int数据位置
*	B连续读取4个byte，拼接为int(反序列化)
*
*	文件模型:
*	data    : 41 42 7f ff ff ff d6 d0 ...
*	index   : 0  1  2  3  4  5  6  7  8
*	pointer :       ^
```

RAFReadDemo:

```java
```





## 8.序列化与基本类型序列化

1) 将类型int 转换为4 byte，或将其它数据类型（如long -> 8 byte）的过程，即将数据转换 为 n个byte序列叫**序列化**（数据 -> n byte）   

   如: 0x7fffffff  ->  [ 7f ，ff， ff， ff ]  

2) **反序列化**，将n byte 转换为一个数据的过程（n byte -> 数据） 

    如: [ 7f ，ff， ff， ff ]  -> 0x7fffffff 

3) RandomAccessFile 提供基本类型的读写方法，可以将基本类型数据序列化到文件或者将文 件内容反序列化为数据

### 案例 :序列化与反序列化

```
```








# IO 流（输入 / 输出流）



## 1.IO 流的核心概念

IO（Input/Output）流是 Java 实现**数据读写**的核心机制，以 “流式传输” 的方式将数据从一个位置传输到另一个位置：

- 输入流（Input）：从外部数据源（文件 / 网络 / 键盘）读取数据到程序

- 输出流（Output）：将程序数据写入外部目的地（文件 / 网络 / 控制台）

- 核心分类：

  | 分类维度 | 类型   | 核心基类                 | 适用场景                       |
  | -------- | ------ | ------------------------ | ------------------------------ |
  | 数据单位 | 字节流 | InputStream/OutputStream | 任意文件（文本 / 图片 / 视频） |
  | 数据单位 | 字符流 | Reader/Writer            | 仅文本文件（.txt/.java）       |

- 核心区别：字符流基于字节流 + 编码表（如 UTF-8），可避免文本文件中文乱码；字节流是 “万能流”，适配所有文件类型。


## 2. 字节流

#### 2.1 核心节点流（直接操作文件）

| 类名             | 作用               |
| ---------------- | ------------------ |
| FileInputStream  | 从文件读取字节数据 |
| FileOutputStream | 向文件写入字节数据 |

#### 2.2 语法格式

```java
// 字节输入流（读取）
FileInputStream fis = new FileInputStream("文件路径");
int read(); // 读1个字节，末尾返回-1
int read(byte[] b); // 读字节到数组，返回读取长度
fis.close(); // 必须关闭释放资源

// 字节输出流（写入）
// append=true：追加写入；默认false：覆盖写入
FileOutputStream fos = new FileOutputStream("文件路径", true);
fos.write(int b); // 写1个字节
fos.write(byte[] b); // 写字节数组
fos.close();
```

#### 2.3 示例（字节流复制文件）

```java
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;

public class ByteStreamDemo {
    public static void main(String[] args) {
        String src = "D:/source.txt";
        String dest = "D:/target_byte.txt";
        
        FileInputStream fis = null;
        FileOutputStream fos = null;
        
        try {
            // 1. 创建流对象
            fis = new FileInputStream(src);
            fos = new FileOutputStream(dest, true);
            
            // 2. 缓冲区读写（1KB缓冲区提升效率）
            byte[] buffer = new byte[1024];
            int len; // 记录每次读取的有效字节数
            while ((len = fis.read(buffer)) != -1) {
                fos.write(buffer, 0, len); // 只写有效字节
            }
            System.out.println("字节流复制完成！");
            
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            // 3. 关闭流（先关输出，后关输入）
            try {
                if (fos != null) fos.close();
                if (fis != null) fis.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
```



## 3. 字符流



#### 3.1 核心节点流

| 类名       | 作用               |
| ---------- | ------------------ |
| FileReader | 从文件读取字符数据 |
| FileWriter | 向文件写入字符数据 |



#### 3.2 语法格式

```java
// 字符输入流（读取）
FileReader fr = new FileReader("文件路径");
int read(); // 读1个字符，末尾返回-1
int read(char[] cbuf); // 读字符到数组
fr.close();

// 字符输出流（写入）
FileWriter fw = new FileWriter("文件路径", true);
fw.write(String str); // 直接写字符串（字符流特有）
fw.flush(); // 刷新缓冲区（避免数据滞留）
fw.close(); // close会自动flush
```



#### 3.3 示例（字符流读写文本）

```java
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;

public class CharStreamDemo {
    public static void main(String[] args) {
        String src = "D:/source.txt"; // 内容：你好 字符流！Hello Char Stream!
        String dest = "D:/target_char.txt";
        
        FileReader fr = null;
        FileWriter fw = null;
        
        try {
            // 1. 创建字符流对象
            fr = new FileReader(src);
            fw = new FileWriter(dest);
            
            // 2. 字符数组缓冲区读写
            char[] cBuffer = new char[1024];
            int len;
            while ((len = fr.read(cBuffer)) != -1) {
                fw.write(cBuffer, 0, len);
                fw.flush(); // 手动刷新确保写入
            }
            System.out.println("字符流读写完成！");
            
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            // 3. 关闭流
            try {
                if (fw != null) fw.close();
                if (fr != null) fr.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
```

**运行结果**：`target_char.txt`完整复制源文件内容，中文无乱码（字符流自动处理编码）。





# File 类与IO流的核心总结

1. File 类仅抽象表示文件 / 目录路径，可操作路径属性但无法读写文件内容，核心方法包括创建、删除、判断状态等。
2. IO 流分为字节流（万能流，适配所有文件）和字符流（仅文本，处理编码），核心使用步骤是 “创建流→缓冲区读写→关闭流”。
3. 缓冲区（字节 / 字符数组）能大幅提升 IO 效率，字节流复制文件时建议使用 8KB 左右的缓冲区大小。



# 实践

## 1.通用文件复制工具

```java
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;

// 支持所有文件类型的复制工具（字节流实现）
public class FileCopyUtil {
    public static void main(String[] args) {
        // 测试：复制图片文件
        copyFile("D:/test.jpg", "D:/copy_test.jpg");
    }
    
    /**
     * 文件复制方法
     * @param srcPath 源文件路径
     * @param destPath 目标文件路径
     */
    public static void copyFile(String srcPath, String destPath) {
        FileInputStream fis = null;
        FileOutputStream fos = null;
        
        try {
            fis = new FileInputStream(srcPath);
            fos = new FileOutputStream(destPath);
            
            // 8KB缓冲区（最优大小之一）
            byte[] buffer = new byte[8192];
            int len;
            long start = System.currentTimeMillis();
            
            while ((len = fis.read(buffer)) != -1) {
                fos.write(buffer, 0, len);
            }
            
            long end = System.currentTimeMillis();
            System.out.println("复制完成！耗时：" + (end - start) + "ms");
            
        } catch (IOException e) {
            System.out.println("复制失败：" + e.getMessage());
        } finally {
            try {
                if (fos != null) fos.close();
                if (fis != null) fis.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
```

