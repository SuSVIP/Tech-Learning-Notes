# 知识点列表

| 编号 | 名称 | 描述 | 级别 |
| ---- | ---- | ---- | ---- |
| 1    |      |      | **   |
| 2    |      |      | **   |
| 3    |      |      | **   |
| 4    |      |      | **   |
| 5    |      |      | **   |
| 6    |      |      | **   |

# 继承的核心概念

继承是面向对象编程（OOP）的三大特性之一，核心思想是 **“复用已有代码，实现层级关系”**。

- 定义：让一个类（**子类 / 派生类**）获取另一个类（**父类 / 基类**）的属性和方法，子类可在此基础上新增或修改功能。
- 关系：子类与父类是 “**is-a**” 关系（如 “狗是动物”“学生是人”）。
- 目的：
  - 减少代码重复（父类定义共性，子类专注个性）。
  - 建立类的层级结构（如 “生物→动物→哺乳动物→狗”）。

# 继承的基本语法

## 1. 关键字与定义格式

用 `extends` 关键字声明继承关系：

```java
// 父类（基类）
class 父类名 {
    // 父类的属性和方法
}

// 子类（派生类）：通过extends继承父类
class 子类名 extends 父类名 {
    // 子类的新增属性和方法（可扩展）
    // 子类可重写父类的方法（可修改）
}
```



## 2. 示例：基础继承关系

以 `Student` 类为例，封装学生的姓名和年龄属性：

```java
// 父类：定义“人”的共性
class Person {
    // 父类属性
    protected String name;  // protected：子类可访问
    private int age;        // private：子类不可直接访问

    // 父类方法
    public void setName(String name) {
        this.name = name;
    }

    public void setAge(int age) {
        if (age > 0) {
            this.age = age;
        }
    }

    public void eat() {
        System.out.println(name + "在吃饭");
    }
}

// 子类：Student继承Person，拥有Person的属性和方法
class Student extends Person {
    // 子类新增属性
    private String studentId;

    // 子类新增方法
    public void setStudentId(String id) {
        studentId = id;
    }

    // 子类重写父类方法（修改行为）
    @Override  // 注解：校验是否符合重写规则
    public void eat() {
        System.out.println(name + "在学校食堂吃饭");  // 可访问父类的protected属性name
    }

    // 子类新增方法
    public void study() {
        System.out.println(name + "（学号：" + studentId + "）在学习");
    }
}
```

## 3. 使用继承后的效果

```java
public class InheritanceDemo {
    public static void main(String[] args) {
        Student stu = new Student();
        
        // 调用父类的方法（继承而来）
        stu.setName("张三");
        stu.setAge(20);
        
        // 调用子类重写的父类方法
        stu.eat();  // 输出：张三在学校食堂吃饭
        
        // 调用子类新增的方法
        stu.setStudentId("2023001");
        stu.study();  // 输出：张三（学号：2023001）在学习
    }
}
```



# 继承的核心特性

## 1. 单继承限制

Java 中一个类**只能直接继承一个父类**（单继承），但可通过 “多层继承” 间接继承多个类：

```java
class A {}
class B extends A {}  // B继承A
class C extends B {}  // C间接继承A（C→B→A）
```

- 为什么不支持多继承？避免 “菱形问题”（多个父类有同名方法时，子类无法确定继承哪一个）。

## 2. 成员的继承规则

子类能继承父类的非私有成员，但访问权限受修饰符限制：

| 父类成员修饰符   | 子类是否可继承 | 子类中访问权限                                         |
| ---------------- | -------------- | ------------------------------------------------------ |
| `public`         | ✅              | 完全访问                                               |
| `protected`      | ✅              | 完全访问                                               |
| 默认（无修饰符） | ✅（同包时）    | 同包可访问                                             |
| `private`        | ❌              | 不可访问（需通过父类的 public/protected 方法间接访问） |

**示例**：子类访问父类的 private 成员

```java
class Parent {
    private int num = 10;  // 私有成员，子类不可直接访问

    // 父类提供public方法，让子类间接访问private成员
    public int getNum() {
        return num;
    }
}

class Child extends Parent {
    public void printParentNum() {
        // System.out.println(num);  // 错误：无法直接访问父类private成员
        System.out.println(getNum());  // 正确：通过父类的public方法访问
    }
}
```

## 3. 方法重写（Override）

子类可对父类的方法进行 “重写”，即修改方法的实现逻辑，但需遵循**重写规则**：

1. **方法签名必须完全一致**：方法名、参数列表（类型、顺序、个数）必须与父类相同。
2. **返回类型兼容**：
   - 基本类型：必须与父类完全相同。
   - 引用类型：可以是父类返回类型的子类（协变返回类型）。
3. **访问修饰符不能更严格**：
   - 父类方法是 `public`，子类重写后不能是 `protected` 或 `private`。
4. **不能抛出更宽泛的异常**：子类抛出的异常范围不能大于父类（异常机制后续讲解）。
5. **被 `final` 修饰的方法不能重写**（`final` 修饰的方法为 “终态方法”）。

**示例：正确与错误的重写**

```java
class Parent {
    public void method(int a) {
        System.out.println("父类方法：" + a);
    }

    public Number getValue() {  // 返回类型为Number（父类）
        return 100;
    }
}

class Child extends Parent {
    // 正确重写：方法签名相同，返回类型更具体（Integer是Number的子类）
    @Override
    public void method(int a) {  // 参数列表与父类一致
        System.out.println("子类重写方法：" + a);
    }

    // 正确：协变返回类型（Integer是Number的子类）
    @Override
    public Integer getValue() {
        return 200;
    }

    // 错误1：参数列表不同（不是重写，是重载）
    /*
    @Override
    public void method(String a) {  // 编译报错：参数类型与父类不同
        System.out.println(a);
    }
    */

    // 错误2：访问修饰符更严格
    /*
    @Override
    protected void method(int a) {  // 编译报错：父类是public，子类不能用protected
        System.out.println(a);
    }
    */
}
```

## 4. `super` 关键字

`super` 用于**访问父类的成员**，解决子类与父类成员同名的冲突：

| 用法                 | 说明                                             |
| -------------------- | ------------------------------------------------ |
| `super.属性名`       | 访问父类的成员变量（当子类有同名属性时）         |
| `super.方法名(参数)` | 调用父类的方法（当子类重写了该方法时）           |
| `super(参数)`        | 调用父类的构造方法（必须在子类构造方法的第一行） |

**示例：`super` 的使用**

```java
class Parent {
    String name = "父类名称";

    public Parent() {
        System.out.println("父类无参构造");
    }

    public Parent(String name) {
        this.name = name;
        System.out.println("父类有参构造：" + name);
    }

    public void print() {
        System.out.println("父类print方法");
    }
}

class Child extends Parent {
    String name = "子类名称";  // 与父类同名的属性

    public Child() {
        super("传递给父类的名称");  // 调用父类的有参构造（必须在第一行）
        System.out.println("子类无参构造");
    }

    @Override
    public void print() {
        super.print();  // 调用父类的print方法
        System.out.println("子类print方法");
        System.out.println("子类name：" + name);  // 访问子类自己的name
        System.out.println("父类name：" + super.name);  // 访问父类的name
    }
}

public class SuperDemo {
    public static void main(String[] args) {
        Child child = new Child();
        child.print();
    }
}
```

**输出结果**：

```txt
父类有参构造：传递给父类的名称
子类无参构造
父类print方法
子类print方法
子类name：子类名称
父类name：传递给父类的名称
```

## 5. 构造方法的继承规则

子类**不能继承父类的构造方法**，但子类构造方法执行时，**必须先调用父类的构造方法**（确保父类初始化完成）：

- 若子类构造方法中未显式调用 `super(...)`，则默认隐含 `super()`（调用父类无参构造）。
- 若父类**没有无参构造**（只定义了有参构造），子类必须显式调用 `super(参数)`，否则编译报错。

**示例：构造方法调用顺序**

```java
class A {
    public A() {
        System.out.println("A的无参构造");
    }
}

class B extends A {
    public B() {
        // 隐含 super()，调用父类A的无参构造
        System.out.println("B的无参构造");
    }
}

class C extends B {
    public C() {
        // 隐含 super()，调用父类B的无参构造
        System.out.println("C的无参构造");
    }
}

public class ConstructorOrderDemo {
    public static void main(String[] args) {
        new C();  // 创建C对象，触发构造方法链
    }
}
```

**输出结果**（构造顺序：父类→子类）：

```txt
A的无参构造
B的无参构造
C的无参构造
```



# `final` 关键字与继承

`final` 可修饰类、方法、变量，用于限制继承和重写：

1. **`final` 类**：不能被继承（如 `java.lang.String` 是 final 类，无法继承）。

   ```java
   final class FinalClass {}
   // class Sub extends FinalClass {}  // 编译报错：不能继承final类
   ```

2. **`final` 方法**：不能被子类重写。

   ```java
   class Parent {
       public final void finalMethod() {}
   }
   class Child extends Parent {
       // @Override
       // public void finalMethod() {}  // 编译报错：不能重写final方法
   }
   ```

   

# 继承的优缺点

## 优点

1. **代码复用**：父类定义共性，子类无需重复编写。
2. **扩展性强**：子类可通过新增方法或重写父类方法扩展功能。
3. **层级清晰**：建立类的继承树，符合现实世界的分类逻辑。

## 缺点

1. **耦合度高**：子类依赖父类的实现，修改父类可能影响所有子类。
2. **灵活性低**：单继承限制了类的扩展维度（可通过接口弥补）。



# 继承的最佳实践

1. **遵循 “is-a” 原则**：只有确实存在 “子类是父类的一种” 关系时才使用继承（如 “Dog is a Animal”），避免为了复用代码而滥用继承。
2. **父类设计为 “模板”**：父类定义通用逻辑，子类专注于个性化实现（可结合抽象类，后续讲解）。
3. **慎用重写**：重写父类方法可能改变原有逻辑，需确保符合 “里氏替换原则”（子类对象可替换父类对象而不影响程序正确性）。



# 总结

继承是实现代码复用和类层级关系的核心机制，通过 `extends` 关键字让子类获取父类的成员。关键知识点：

- 单继承限制与多层继承的使用。
- 方法重写的规则与 `@Override` 注解。
- `super` 关键字访问父类成员和构造方法。
- 构造方法的调用顺序（先父后子）。
- `final` 对继承和重写的限制。

合理使用继承可显著提升代码效率，但需注意降低耦合度，避免过度设计。
