# 知识点列表

| 编号 | 名称 | 描述 | 级别 |
| ---- | ---- | ---- | ---- |
| 1    |      |      | **   |
| 2    |      |      | **   |
| 3    |      |      | **   |
| 4    |      |      | **   |
| 5    |      |      | **   |
| 6    |      |      | **   |

# 封装的核心概念

封装是面向对象编程（OOP）的三大特性之一（另外两个是继承和多态），核心思想是 **“隐藏内部细节，暴露公共接口”**。

- **隐藏细节**：将类的属性（数据）和实现逻辑私有化，禁止外部直接访问。
- **暴露接口**：通过公共（public）方法提供对属性的访问和操作，控制外部交互的方式。

**目的**：

- 保护数据安全性（避免外部随意修改导致数据异常）。
- 降低耦合度（外部只需关注 “如何用”，无需知道 “如何实现”）。
- 提高代码可维护性（内部修改时，只要接口不变，外部无需调整）。

# 封装的实现步骤

## 1. 语法格式

1. **私有化属性**：用 `private` 修饰类的成员变量，禁止外部直接访问。
2. **提供公共方法**：通过 `public` 的 `getter`（获取属性值）和 `setter`（设置属性值）方法，控制对属性的操作。
3. **添加逻辑验证**：在 `setter` 方法中加入数据合法性校验，确保属性值符合业务规则。



```java
[访问修饰符] class 类名 {
    // 成员变量：访问修饰符 数据类型 变量名;
    访问修饰符 数据类型 变量名1;
    访问修饰符 数据类型 变量名2;
    ...
    
    // 成员方法：[访问修饰符] [返回值类型] 方法名(参数列表) { 方法体 }
    [访问修饰符] 返回值类型 方法名1(参数类型 参数名) {
        // 方法体：实现行为的代码
    }
    
    [访问修饰符] 返回值类型 方法名2(参数类型1 参数名1, 参数类型2 参数名2) {
        // 方法体
    }
    ...
}
```



## 2. 示例（Student 类）

以 `Student` 类为例，封装学生的姓名和年龄属性：

```java
// 封装的Student类
public class Student {
    // 1. 私有化属性（外部无法直接访问）
    private String name;  // 姓名
    private int age;      // 年龄

    // 2. 提供公共getter方法（获取属性值）
    public String getName() {
        return name;
    }

    // 3. 提供公共setter方法（设置属性值，可添加验证）
    public void setName(String name) {
        // 验证：姓名不能为null或空字符串
        if (name != null && !name.trim().isEmpty()) {
            this.name = name;
        } else {
            System.out.println("姓名不能为空！");
        }
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        // 验证：年龄必须在0-120之间
        if (age >= 0 && age <= 120) {
            this.age = age;
        } else {
            System.out.println("年龄必须在0-120之间！");
        }
    }
}
```

### 使用封装类：

```java
public class EncapsulationDemo {
    public static void main(String[] args) {
        Student stu = new Student();

        // 错误：无法直接访问private属性
        // stu.name = "张三";  // 编译报错
        // stu.age = -5;      // 编译报错

        // 正确：通过setter方法设置属性（自动触发验证）
        stu.setName("张三");  // 合法，成功设置
        stu.setAge(-5);      // 不合法，打印错误提示
        stu.setAge(20);      // 合法，成功设置

        // 通过getter方法获取属性值
        System.out.println("姓名：" + stu.getName());  // 输出：张三
        System.out.println("年龄：" + stu.getAge());    // 输出：20
    }
}
```

**运行结果**：

```txt
年龄必须在0-120之间！
姓名：张三
年龄：20
```



# 访问修饰符：控制封装范围

Java 通过**访问修饰符**控制类、属性、方法的可见性，是实现封装的关键工具。常用修饰符的访问范围如下：

| 修饰符           | 本类内部 | 同一包内其他类 | 不同包的子类 | 其他包非子类 |
| ---------------- | -------- | -------------- | ------------ | ------------ |
| `private`        | ✅        | ❌              | ❌            | ❌            |
| 默认（无修饰符） | ✅        | ✅              | ❌            | ❌            |
| `protected`      | ✅        | ✅              | ✅            | ❌            |
| `public`         | ✅        | ✅              | ✅            | ✅            |

**封装常用组合**：

- 属性：通常用 `private`（完全隐藏，仅本类可见）。
- getter/setter 方法：通常用 `public`（完全暴露，供外部调用）。
- 内部工具方法：可用 `private`（仅本类内部使用，不暴露给外部）。





# 构造方法与封装

构造方法用于对象初始化，结合封装可在创建对象时就保证数据合法性。

```java
public class Student {
    private String name;
    private int age;

    // 无参构造
    public Student() {}

    // 有参构造（添加验证逻辑）
    public Student(String name, int age) {
        // 复用setter的验证逻辑，避免代码重复
        setName(name);
        setAge(age);
    }

    // getter和setter（同上例）
    public String getName() { return name; }
    public void setName(String name) {
        if (name != null && !name.trim().isEmpty()) {
            this.name = name;
        } else {
            System.out.println("姓名不能为空！");
        }
    }
    public int getAge() { return age; }
    public void setAge(int age) {
        if (age >= 0 && age <= 120) {
            this.age = age;
        } else {
            System.out.println("年龄必须在0-120之间！");
        }
    }
}
```

**使用有参构造创建对象**：

```java
public class ConstructorDemo {
    public static void main(String[] args) {
        // 创建对象时直接初始化，触发验证
        Student stu = new Student("李四", 150);  // 年龄不合法，打印错误提示
        System.out.println("年龄：" + stu.getAge());  // 输出：0（默认值，未被修改）

        Student stu2 = new Student("王五", 22);  // 合法
        System.out.println("姓名：" + stu2.getName() + "，年龄：" + stu2.getAge());  // 输出：王五，22
    }
}
```



# 封装的进阶：隐藏方法实现细节

封装不仅限于属性，还包括**隐藏方法的具体实现**，外部只需通过方法名和参数调用，无需关心内部逻辑

```java
public class Calculator {
    // 私有方法：隐藏加法的具体实现（比如后续可优化为高效算法）
    private int add(int a, int b) {
        return a + b;
    }

    // 私有方法：隐藏乘法的具体实现
    private int multiply(int a, int b) {
        int result = 0;
        for (int i = 0; i < b; i++) {
            result = add(result, a);  // 内部复用add方法
        }
        return result;
    }

    // 公共方法：暴露给外部的“计算接口”
    public int calculate(int a, int b, String operator) {
        switch (operator) {
            case "+":
                return add(a, b);
            case "*":
                return multiply(a, b);
            default:
                throw new IllegalArgumentException("不支持的运算符：" + operator);
        }
    }
}
```

**使用计算器**：

```java
public class CalculatorDemo {
    public static void main(String[] args) {
        Calculator calc = new Calculator();
        
        // 调用公共接口，无需知道内部如何实现加法/乘法
        System.out.println("3 + 5 = " + calc.calculate(3, 5, "+"));    // 8
        System.out.println("4 * 6 = " + calc.calculate(4, 6, "*"));    // 24
    }
}
```

**优势**：如果后续需要优化 `multiply` 方法（比如直接用 `a * b` 替换循环），外部调用代码无需任何修改。



# 封装的好处总结

1. **数据安全**：通过 `setter` 验证避免非法数据（如年龄为负、姓名为空）。
2. **降低耦合**：外部依赖的是接口（方法），而非内部实现，减少修改影响范围。
3. **代码可控**：所有对属性的操作都集中在方法中，便于统一管理（如日志记录、权限校验）。
4. **信息隐藏**：只暴露必要功能，隐藏复杂细节（如计算器的乘法实现），简化使用难度。

# 常见误区

1. **“封装就是把属性设为 private”**：不完整。封装的核心是 “合理控制访问范围”，需结合 `getter/setter`、访问修饰符、方法逻辑共同实现。
2. **“所有属性都必须提供 getter 和 setter”**：错误。如果某个属性不希望被外部修改，可只提供 `getter` 而不提供 `setter`（如只读属性）。
3. **“封装会增加代码量，没必要”**：短期看似繁琐，但长期来看，能显著提高代码的可维护性和安全性，尤其在大型项目中作用明显。
