# 知识点列表

| 编号 | 名称                   | 描述                                                 | 级别 |
| ---- | ---------------------- | ---------------------------------------------------- | ---- |
| 1    | 异常的定义与本质       | 理解异常是程序运行时的非正常状态，明确其核心作用     | **   |
| 2    | Java 异常体系结构      | 掌握 Throwable 及其子类（Error/Exception）的层级关系 | **   |
| 3    | 异常的分类             | 区分运行时异常（非受检）与编译时异常（受检）         | **   |
| 4    | 异常处理机制           | 熟练使用 try-catch-finally 捕获并处理异常            | **   |
| 5    | throws 与 throw 关键字 | 掌握异常声明与手动抛出的语法及场景                   | **   |
| 6    | 自定义异常             | 学会根据业务需求定义专属异常类                       | **   |

# 异常处理的核心概念

异常（Exception）是 Java 中描述 **程序运行时非正常状态** 的机制，是面向对象编程中错误处理的核心技术。

- 定义：程序在执行过程中遇到的意外情况（如除零、空指针、文件不存在等），会导致程序中断执行，这类情况被称为异常。
- 本质：异常是一个 “异常对象”，封装了错误的类型、原因、发生位置等信息（继承自 `Throwable` 类）。
- 目的：
  - 增强程序 **健壮性**（避免程序因错误直接崩溃）。
  - 便于 **错误定位**（通过异常信息快速排查问题）。
  - 实现 **优雅的错误处理**（替代繁琐的 `if-else` 判断）。

# 异常的体系结构

Java 中所有异常都继承自顶层类 `java.lang.Throwable`，其下分为两大核心子类：`Error`（错误）和 `Exception`（异常），两者各司其职，不可混淆。

```tex
Throwable（顶层父类）
├─ Error（错误）：JVM层面的严重问题，程序无法处理
│  ├─ OutOfMemoryError（内存溢出错误）
│  ├─ StackOverflowError（栈溢出错误）
│  └─ NoClassDefFoundError（类未找到错误）
└─ Exception（异常）：程序层面的错误，可通过代码处理
   ├─ 编译时异常（受检异常 Checked Exception）：编译期强制要求处理
   │  ├─ IOException（IO异常）
   │  ├─ SQLException（数据库异常）
   │  └─ ClassNotFoundException（类找不到异常）
   └─ 运行时异常（非受检异常 Unchecked Exception）：运行时才会出现，编译不强制处理
      ├─ NullPointerException（空指针异常）
      ├─ ArithmeticException（算术异常，如除零）
      ├─ ArrayIndexOutOfBoundsException（数组索引越界异常）
      └─ ClassCastException（类型转换异常）
```

**核心区别**：

- `Error`：严重错误，程序无法恢复（如内存溢出），无需处理，通常是 JVM 或系统级问题。
- `Exception`：可处理的异常，是开发中重点关注的对象（尤其是运行时异常和编译时异常）。



# 异常的分类（重点）

根据编译期是否强制处理，`Exception` 分为两类，处理规则和使用场景完全不同：

## 1. 编译时异常（受检异常 Checked Exception）

- 特点：编译期会检查，必须显式处理（否则编译报错），通常是外部环境导致的错误（如文件不存在、网络中断）。
- 常见示例：`IOException`（文件读写异常）、`SQLException`（数据库连接异常）、`ParseException`（日期格式化异常）。
- 处理要求：必须通过 `try-catch` 捕获或 `throws` 声明，否则无法编译。

## 2. 运行时异常（非受检异常 Unchecked Exception）

- 特点：编译期不检查，运行时才会触发，通常是代码逻辑错误导致（如空指针、除零）。
- 常见示例：`NullPointerException`（空指针）、`ArithmeticException`（除零）、`ArrayIndexOutOfBoundsException`（数组越界）、`IllegalArgumentException`（非法参数）。
- 处理要求：可选择性处理（建议通过优化代码避免，如判空、参数校验）。



# 异常处理的核心机制

Java 提供了 3 种核心异常处理方式：`try-catch-finally`（捕获处理）、`throws`（声明异常）、`throw`（手动抛异常），需根据场景灵活使用。

## 1. try-catch：捕获并处理异常

### 语法规则

```java
try {
    // 可能抛出异常的代码（核心执行逻辑）
} catch (异常类型1 异常变量名) {
    // 处理异常类型1的逻辑（如打印日志、返回默认值）
} catch (异常类型2 异常变量名) {
    // 处理异常类型2的逻辑（可多个catch，从上到下捕获不同异常）
}
```

### 基本示例（捕获除零异常）

```java
public class TryCatchDemo {
    public static void main(String[] args) {
        int a = 10;
        int b = 0;

        try {
            // 可能抛出ArithmeticException（除零异常）
            int result = a / b;
            System.out.println("结果：" + result); // 异常后不会执行
        } catch (ArithmeticException e) {
            // 捕获异常并处理
            System.out.println("异常原因：" + e.getMessage()); // 输出：/ by zero
            System.out.println("异常类型：" + e.getClass().getName()); // 输出：java.lang.ArithmeticException
            e.printStackTrace(); // 打印完整异常栈（开发调试常用）
        }

        System.out.println("程序继续执行..."); // 异常处理后，程序不会崩溃
    }
}
```

### 关键注意事项

- 多个 `catch` 块时，**异常类型需从子类到父类**（否则父类异常会覆盖子类，编译报错）。

  ```java
  // 错误示例：Exception是所有异常的父类，放在前面会导致子类异常无法捕获
  catch (Exception e) { ... }
  catch (ArithmeticException e) { ... } // 编译报错：无法访问的代码
  
  // 正确示例：先子类后父类
  catch (ArithmeticException e) { ... }
  catch (Exception e) { ... } // 捕获其他未明确处理的异常
  ```

  

- 异常变量 `e` 可调用常用方法：

  - `e.getMessage()`：获取异常简要描述（如 “/by zero”）。
  - `e.printStackTrace()`：打印完整异常栈（包含发生位置，调试必备）。

## 2. try-catch-finally：捕获处理 + 最终执行逻辑

### 语法规则

```java
try {
    // 可能抛出异常的代码
} catch (异常类型 异常变量名) {
    // 异常处理逻辑
} finally {
    // 无论是否发生异常，都会执行的代码（如释放资源）
}
```

### 核心作用

`finally` 块用于执行 **必须完成的操作**（如关闭文件、释放数据库连接、关闭流），即使 `try` 或 `catch` 中有 `return`，`finally` 仍会执行（特殊情况：`System.exit(0)` 强制退出 JVM 除外）。

### 示例（文件操作释放资源）

```java
import java.io.FileInputStream;
import java.io.IOException;

public class TryCatchFinallyDemo {
    public static void main(String[] args) {
        FileInputStream fis = null;
        try {
            // 可能抛出FileNotFoundException（编译时异常，需处理）
            fis = new FileInputStream("test.txt");
            System.out.println("文件打开成功");
        } catch (IOException e) {
            System.out.println("文件操作异常：" + e.getMessage());
        } finally {
            // 无论是否异常，都关闭流（释放资源）
            if (fis != null) {
                try {
                    fis.close(); // close()可能抛出IOException，需嵌套捕获
                    System.out.println("流已关闭");
                } catch (IOException e) {
                    System.out.println("关闭流失败：" + e.getMessage());
                }
            }
        }
    }
}
```

## 3. throws：声明异常（不处理，交给调用者处理）

### 语法规则

- 用于方法声明处，指明该方法可能抛出的异常类型，将异常处理责任交给调用者。
- 语法：`public 返回值类型 方法名(参数) throws 异常类型1, 异常类型2 { ... }`

### 示例（声明编译时异常）

```java
import java.io.IOException;

// 方法声明抛出IOException（编译时异常），调用者必须处理
public class ThrowsDemo {
    public static void readFile() throws IOException {
        // 打开文件（可能抛出IOException）
        new FileInputStream("test.txt");
        System.out.println("文件读取成功");
    }

    public static void main(String[] args) {
        try {
            // 调用声明异常的方法，必须捕获或再次声明
            readFile();
        } catch (IOException e) {
            System.out.println("处理readFile抛出的异常：" + e.getMessage());
        }

        // 也可选择再次声明，交给JVM处理（程序会崩溃）
        // public static void main(String[] args) throws IOException {
        //     readFile();
        // }
    }
}
```

### 关键注意事项

- 运行时异常（如 `NullPointerException`）可声明也可不声明，编译不强制。
- 编译时异常必须声明或捕获，否则编译报错。
- 子类重写父类方法时，抛出的异常类型不能超过父类方法声明的范围（可相同或子类）。

## 4. throw：手动抛出异常

### 语法规则

- 用于方法内部，手动创建并抛出异常对象（主动触发异常）。
- 语法：`throw new 异常类型(异常描述);`

### 核心场景

- 业务逻辑校验（如参数非法、权限不足）。
- 自定义异常触发。

### 示例（参数校验）

```java
public class ThrowDemo {
    // 计算平方根（参数必须非负）
    public static double sqrt(double num) {
        // 手动校验参数，非法则抛出异常
        if (num < 0) {
            throw new IllegalArgumentException("参数不能为负数：" + num);
        }
        return Math.sqrt(num);
    }

    public static void main(String[] args) {
        try {
            sqrt(-4); // 触发手动抛出的IllegalArgumentException
        } catch (IllegalArgumentException e) {
            System.out.println("异常处理：" + e.getMessage()); // 输出：参数不能为负数：-4
        }
    }
}
```

### 与 throws 的区别

| 关键字 | 作用位置   | 核心作用               | 语法格式                           |
| ------ | ---------- | ---------------------- | ---------------------------------- |
| throw  | 方法内部   | 手动创建并抛出异常对象 | `throw new 异常类(...)`            |
| throws | 方法声明处 | 声明方法可能抛出的异常 | `方法名() throws 异常类1, 异常类2` |



# 自定义异常

Java 内置异常无法满足所有业务需求（如 “用户余额不足”“订单状态非法”），此时需要自定义异常类，遵循以下规则：

## 自定义异常的实现步骤

1. 继承 `Exception`（编译时异常）或 `RuntimeException`（运行时异常）。
2. 提供无参构造和带异常信息的构造方法（便于传递异常描述）。

## 示例（自定义 “余额不足异常”）

```java
// 自定义编译时异常（继承Exception）
class InsufficientBalanceException extends Exception {
    // 无参构造
    public InsufficientBalanceException() {
        super();
    }

    // 带异常信息的构造
    public InsufficientBalanceException(String message) {
        super(message); // 调用父类构造，传递异常描述
    }
}

// 业务类：处理用户转账
class UserAccount {
    private double balance;

    public UserAccount(double balance) {
        this.balance = balance;
    }

    // 转账方法：余额不足时抛出自定义异常
    public void transfer(double amount) throws InsufficientBalanceException {
        if (amount > balance) {
            // 手动抛出自定义异常
            throw new InsufficientBalanceException("余额不足！当前余额：" + balance + "，转账金额：" + amount);
        }
        balance -= amount;
        System.out.println("转账成功！剩余余额：" + balance);
    }
}

// 测试类
public class CustomExceptionDemo {
    public static void main(String[] args) {
        UserAccount account = new UserAccount(1000.0);
        try {
            account.transfer(1500.0); // 触发自定义异常
        } catch (InsufficientBalanceException e) {
            System.out.println("转账失败：" + e.getMessage());
            e.printStackTrace();
        }
    }
}
```

## 运行结果

```plaintext
转账失败：余额不足！当前余额：1000.0，转账金额：1500.0
InsufficientBalanceException: 余额不足！当前余额：1000.0，转账金额：1500.0
    at UserAccount.transfer(CustomExceptionDemo.java:23)
    at CustomExceptionDemo.main(CustomExceptionDemo.java:32)
```

## 选型建议

- 若业务异常需要强制调用者处理（如转账余额不足），继承 `Exception`（编译时异常）。
- 若业务异常是逻辑错误（可通过代码优化避免），继承 `RuntimeException`（运行时异常）。

# 异常处理的应用场景

异常处理在实际开发中无处不在，典型场景包括：

## 1. 外部资源操作（文件、网络、数据库）

这类操作依赖外部环境，易出现异常（如文件不存在、网络中断），必须通过 `try-catch-finally` 处理并释放资源。

```java
// 数据库连接释放示例
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;

public class ResourceHandleDemo {
    public static void main(String[] args) {
        Connection conn = null;
        try {
            // 连接数据库（可能抛出SQLException）
            conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/test", "root", "123456");
            System.out.println("数据库连接成功");
        } catch (SQLException e) {
            System.out.println("数据库连接失败：" + e.getMessage());
        } finally {
            // 释放数据库连接
            if (conn != null) {
                try {
                    conn.close();
                    System.out.println("数据库连接已关闭");
                } catch (SQLException e) {
                    System.out.println("关闭连接失败：" + e.getMessage());
                }
            }
        }
    }
}
```



## 2. 业务逻辑校验（参数、状态校验）

通过 `throw` 手动抛出异常，替代繁琐的 `if-else` 判断，使代码更简洁。

```java
// 订单状态校验
class OrderService {
    public void payOrder(String orderId, int status) {
        // 订单状态：0-未创建，1-待支付，2-已支付
        if (status != 1) {
            throw new IllegalStateException("订单状态非法！订单ID：" + orderId + "，当前状态：" + status);
        }
        System.out.println("订单" + orderId + "支付成功");
    }
}

public class BusinessCheckDemo {
    public static void main(String[] args) {
        OrderService service = new OrderService();
        try {
            service.payOrder("ORDER_001", 2); // 已支付状态，触发异常
        } catch (IllegalStateException e) {
            System.out.println("支付失败：" + e.getMessage());
        }
    }
}
```

## 3. 框架 / 工具类开发

自定义异常统一错误类型，便于调用者识别和处理（如 Spring 框架的 `NullPointerException`、`IllegalArgumentException`）。



# 异常处理的优缺点

## 优点

1. **增强程序健壮性**：避免程序因错误直接崩溃，可优雅处理异常场景。
2. **便于错误调试**：异常对象包含错误类型、位置、原因，快速定位问题。
3. **简化代码逻辑**：替代大量 `if-else` 校验（如参数非法、资源不存在）。
4. **统一错误处理**：通过自定义异常实现业务错误标准化。

## 缺点

1. **性能开销**：异常对象创建和栈跟踪会消耗一定系统资源（避免过度使用）。
2. **代码冗余**：复杂场景下，`try-catch-finally` 会增加代码行数。
3. **过度捕获风险**：捕获 `Exception` 等父类异常，可能隐藏真正的错误（如空指针被笼统处理）。




# 异常处理的常见问题与注意事项

##  1. finally 和 return 的执行顺序

- 无论 `try` 或 `catch` 中是否有 `return`，`finally` 都会先执行，再执行 `return`。
- 若 `finally` 中也有 `return`，会覆盖 `try/catch` 中的返回值（不推荐）。

```java
public class FinallyReturnDemo {
    public static int test() {
        try {
            return 1; // 不会直接返回，先执行finally
        } finally {
            System.out.println("finally执行");
            // return 2; // 若打开，返回值为2，覆盖try中的1
        }
    }

    public static void main(String[] args) {
        System.out.println("返回值：" + test());
        // 输出：
        // finally执行
        // 返回值：1
    }
}
```

## 2. 如何避免常见异常？

- 空指针异常（`NullPointerException`）：调用方法前先判空（`if (obj != null)`）。
- 数组索引越界（`ArrayIndexOutOfBoundsException`）：访问数组前校验索引（`if (index >=0 && index < array.length)`）。
- 除零异常（`ArithmeticException`）：计算前校验除数（`if (b != 0)`）。
- 类型转换异常（`ClassCastException`）：转型前用 `instanceof` 判断。

## 3. 异常链的使用

通过 `initCause()` 方法将原始异常传递给新异常，保留完整错误链路（适用于自定义异常包装原始异常）。

```java
public class ExceptionChainDemo {
    public static void main(String[] args) {
        try {
            int result = 10 / 0;
        } catch (ArithmeticException e) {
            // 包装原始异常到自定义异常
            RuntimeException ex = new RuntimeException("计算失败");
            ex.initCause(e); // 关联原始异常
            throw ex;
        }
    }
}
```



# 异常处理的核心总结

1. **核心体系**：`Throwable` 是所有异常 / 错误的父类，核心关注 `Exception` 及其子类（编译时 / 运行时异常）。
2. **处理机制**：
   - 捕获处理：`try-catch`（处理异常）+ `finally`（释放资源）。
   - 转移责任：`throws`（声明异常，交给调用者）。
   - 主动触发：`throw`（手动抛出异常，用于业务校验）。
3. **自定义异常**：继承 `Exception`（编译时）或 `RuntimeException`（运行时），提供带描述的构造方法。
4. **核心原则**：
   - 避免过度捕获（不滥用 `catch (Exception e)`）。
   - 资源操作必须在 `finally` 中释放（或使用 try-with-resources 语法，Java7+）。
   - 业务异常优先用自定义异常，便于统一处理。
5. **核心价值**：让程序在错误场景下仍能可控执行，同时简化错误定位和处理逻辑，是构建健壮 Java 程序的必备技术。
