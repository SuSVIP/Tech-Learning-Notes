# 知识点列表

| 编号 | 名称 | 描述 | 级别 |
| ---- | ---- | ---- | ---- |
| 1    |      |      | **   |
| 2    |      |      | **   |
| 3    |      |      | **   |
| 4    |      |      | **   |
| 5    |      |      | **   |
| 6    |      |      | **   |

# 抽象类与接口的核心概念

抽象类与接口是 Java 中实现 **代码复用** 和 **行为规范** 的核心技术，也是面向对象编程（OOP）的重要体现。

- 抽象类 = 共性属性 / 方法 + 强制子类实现的抽象方法（本质是「模板」）；
- 接口 = 统一行为规范（本质是「契约」），突破单继承限制。



# 抽象类（Abstract Class）

## 1. 定义与本质

- 用 `abstract` 关键字修饰的类，是 **不完全的类**（包含未实现的抽象方法）；
- 本质：抽取多个子类的「共性属性和方法」，同时强制子类遵循统一规范（抽象方法），相当于 “模板”。

## 2. 语法规则

### （1）核心关键字

- 类修饰：`abstract class 类名 {}`；
- 抽象方法：`public abstract 返回值类型 方法名(参数列表);`（无方法体，`{}` 省略）。

### （2）类的组成

可包含：抽象方法、普通方法、成员变量（普通属性）、构造方法。

### （3）关键限制

1. 不能直接实例化（`new 抽象类名()` 报错）；
2. 子类必须重写所有抽象方法（除非子类也是抽象类）；
3. 支持 **单继承**（子类只能继承一个抽象类）；
4. 抽象方法不能被 `private`、`final`、`static` 修饰（冲突：私有无法重写、final 禁止重写、static 属于类而非实例）。

## 3. 核心特点

- 「部分实现，部分抽象」：共性逻辑（普通方法）直接复用，个性化逻辑（抽象方法）强制子类实现；
- 构造方法的作用：不是实例化自身，而是供子类通过 `super()` 调用，初始化抽象类中的共性属性。

## 4. 使用场景

- 多个子类存在 **共性属性和方法**（如员工类的「姓名、工号」属性，「显示信息」方法）；
- 需强制子类实现特定逻辑（如不同员工的「计算薪资」方法，规则不同但必须实现）

##  5. 简单案例

```java
// 抽象父类（模板）
abstract class Animal {
    String name; // 共性属性

    // 构造方法（供子类初始化）
    public Animal(String name) {
        this.name = name;
    }

    // 普通方法（共性逻辑复用）
    public void eat() {
        System.out.println(name + "正在进食");
    }

    // 抽象方法（强制子类实现）
    public abstract void makeSound();
}

// 子类实现
class Dog extends Animal {
    public Dog(String name) {
        super(name); // 调用父类构造方法
    }

    @Override
    public void makeSound() {
        System.out.println(name + "汪汪叫");
    }
}

// 测试
public class AbstractDemo {
    public static void main(String[] args) {
        Animal dog = new Dog("旺财");
        dog.eat(); // 复用父类方法：旺财正在进食
        dog.makeSound(); // 子类实现：旺财汪汪叫
    }
}
```



# 接口（Interface）

## 1. 定义与本质

- 用 `interface` 关键字定义的「行为规范集合」，仅包含方法签名（无实现，Java8+ 新增默认 / 静态方法）；
- 本质：「契约」—— 规定类必须实现的行为，不关心类的具体实现，支持多实现。

## 2. 语法规则

### （1）核心关键字

- 接口定义：`interface 接口名 {}`；
- 类实现接口：`class 类名 implements 接口名1, 接口名2 {}`（多实现）。

### （2）成员组成（按版本区分）

| Java 版本 | 允许成员                                        | 说明                                                         |
| --------- | ----------------------------------------------- | ------------------------------------------------------------ |
| 8 及之前  | 抽象方法、常量                                  | 抽象方法默认 `public abstract`（可省略）；常量默认 `public static final`（可省略） |
| 8+        | 新增默认方法（`default`）、静态方法（`static`） | 默认方法有方法体，子类可重写；静态方法需通过接口名调用       |

### （3）关键限制

1. 不能直接实例化；
2. 类支持 **多实现**（一个类可实现多个接口）；
3. 接口支持 **多继承**（一个接口可继承多个接口，如 `interface A extends B, C {}`）；
4. 接口中无构造方法，不能定义普通成员变量（仅支持常量）。

## 3. 核心特点

- 「纯行为规范」：不关心类的继承关系，只约束行为（如 “充电”“攻击”）；
- 灵活性强：突破单继承限制，让无关联的类实现统一行为；
- Java8+ 默认方法：解决接口扩展问题（新增方法不破坏现有实现类）。

## 4. 使用场景

- 多个 **无继承关系** 的类需要遵循统一行为规范（如手机、笔记本、手表都需 “充电”）；
- 需为类添加额外行为（如游戏角色可同时实现「攻击」「防御」「移动」多个接口）；
- 定义框架中的规范（如 Java 的 `Runnable`、`Comparable` 接口）。

## 5. 简单案例

```java
// 接口（行为规范）
interface Chargeable {
    // 抽象方法（默认 public abstract）
    void charge();

    // Java8+ 静态方法（接口名调用）
    static void safetyTip() {
        System.out.println("充电提示：使用原装充电器");
    }

    // Java8+ 默认方法（子类可继承/重写）
    default void stopCharge() {
        System.out.println("充满电，自动停止");
    }
}

// 实现类1：手机
class Phone implements Chargeable {
    @Override
    public void charge() {
        System.out.println("手机：Type-C接口 5V/2A 充电");
    }
}

// 实现类2：笔记本
class Laptop implements Chargeable {
    @Override
    public void charge() {
        System.out.println("笔记本：PD接口 20V/3A 快充");
    }

    // 重写默认方法
    @Override
    public void stopCharge() {
        System.out.println("笔记本：电量100%，断电保护");
    }
}

// 测试
public class InterfaceDemo {
    public static void main(String[] args) {
        Chargeable phone = new Phone();
        Chargeable laptop = new Laptop();

        phone.charge();      // 手机：Type-C接口 5V/2A 充电
        phone.stopCharge();  // 充满电，自动停止（继承默认方法）

        laptop.charge();     // 笔记本：PD接口 20V/3A 快充
        laptop.stopCharge(); // 笔记本：电量100%，断电保护（重写默认方法）

        Chargeable.safetyTip(); // 充电提示：使用原装充电器（静态方法）
    }
}
```



# 实践

## 员工薪资计算（模板复用）

公司有普通员工（固定薪资）和经理（薪资 + 奖金），需统一计算薪资，抽取共性属性（姓名、工号）和方法（显示信息），强制子类实现薪资计算逻辑。

```java
// 抽象父类：员工类（模板类）
abstract class Employee {
    // 共性属性
    String empName;
    String empId;

    // 构造方法（供子类调用）
    public Employee(String empName, String empId) {
        this.empName = empName;
        this.empId = empId;
    }

    // 普通方法（子类直接继承）
    public void showInfo() {
        System.out.println("员工ID：" + empId + "，姓名：" + empName);
    }

    // 抽象方法（强制子类实现）
    public abstract double calculateSalary();
}

// 子类1：普通员工（实现抽象方法）
class RegularEmployee extends Employee {
    double baseSalary; // 独有属性

    public RegularEmployee(String empName, String empId, double baseSalary) {
        super(empName, empId);
        this.baseSalary = baseSalary;
    }

    @Override
    public double calculateSalary() {
        return baseSalary; // 普通员工薪资=基本工资
    }
}

// 子类2：经理（实现抽象方法）
class Manager extends Employee {
    double baseSalary;
    double bonus; // 独有属性

    public Manager(String empName, String empId, double baseSalary, double bonus) {
        super(empName, empId);
        this.baseSalary = baseSalary;
        this.bonus = bonus;
    }

    @Override
    public double calculateSalary() {
        return baseSalary + bonus; // 经理薪资=基本工资+奖金
    }
}

// 测试类
public class AbstractClassDemo {
    public static void main(String[] args) {
        Employee regular = new RegularEmployee("张三", "E001", 8000.0);
        Employee manager = new Manager("李四", "M001", 15000.0, 5000.0);

        regular.showInfo();
        System.out.println("普通员工月薪：" + regular.calculateSalary()); // 输出：8000.0

        manager.showInfo();
        System.out.println("经理月薪：" + manager.calculateSalary()); // 输出：20000.0
    }
}
```

抽象类成功抽取了员工的共性（姓名、工号、显示信息），通过抽象方法 `calculateSalary()` 强制子类实现个性化薪资逻辑，体现 “模板复用 + 规范约束” 的核心价值。



## 设备充电规范（契约约束）

手机、笔记本、智能手表是不同设备（无继承关系），但都需要 “充电” 功能，需定义统一充电规范，让各设备实现自身充电逻辑。

```java
// 接口：充电规范（契约）
interface Chargeable {
    // 抽象方法（默认public abstract）
    void charge();

    // Java8+ 静态方法（接口直接调用）
    static void showChargeTip() {
        System.out.println("充电安全提示：请勿使用非原装充电器！");
    }

    // Java8+ 默认方法（子类可继承或重写）
    default void stopCharge() {
        System.out.println("设备已充满，停止充电");
    }
}

// 实现类1：手机
class Phone implements Chargeable {
    @Override
    public void charge() {
        System.out.println("手机：Type-C接口，5V/2A充电中...");
    }

    // 重写默认方法
    @Override
    public void stopCharge() {
        System.out.println("手机电量100%，自动断电");
    }
}

// 实现类2：笔记本电脑
class Laptop implements Chargeable {
    @Override
    public void charge() {
        System.out.println("笔记本：PD接口，20V/3A快充中...");
    }
}

// 测试类
public class InterfaceDemo {
    public static void main(String[] args) {
        // 接口引用指向实现类对象（多态）
        Chargeable phone = new Phone();
        Chargeable laptop = new Laptop();

        // 调用接口方法（运行时执行实现类逻辑）
        phone.charge();      // 输出：手机：Type-C接口，5V/2A充电中...
        phone.stopCharge();  // 输出：手机电量100%，自动断电

        laptop.charge();     // 输出：笔记本：PD接口，20V/3A快充中...
        laptop.stopCharge(); // 输出：设备已充满，停止充电（继承默认方法）

        // 调用接口静态方法
        Chargeable.showChargeTip(); // 输出：充电安全提示：请勿使用非原装充电器！
    }
}
```

接口突破了单继承限制，让无关联的设备统一实现 “充电” 行为，Java8+ 的默认方法和静态方法增强了接口灵活性，既保证了规范统一，又避免了子类代码冗余。

## 抽象类 + 接口综合实践 —— 游戏角色设计

游戏中有战士、法师、射手三种角色，共性：都有姓名、等级（抽象类抽取）；个性：战士能 “物理攻击”“防御”，法师能 “魔法攻击”“防御”，射手能 “远程攻击”，需通过接口定义攻击 / 防御行为。

```java
// 抽象类：游戏角色（抽取共性）
abstract class GameRole {
    String name;
    int level;

    public GameRole(String name, int level) {
        this.name = name;
        this.level = level;
    }

    // 共性方法
    public void showRoleInfo() {
        System.out.println("角色：" + name + "，等级：" + level);
    }

    // 抽象方法：角色专属技能（子类各自实现）
    public abstract void specialSkill();
}

// 接口1：物理攻击行为
interface PhysicalAttack {
    void physicalAttack();
}

// 接口2：魔法攻击行为
interface MagicAttack {
    void magicAttack();
}

// 接口3：防御行为
interface Defend {
    void defend();
}

// 子类1：战士（继承抽象类+实现多个接口）
class Warrior extends GameRole implements PhysicalAttack, Defend {
    public Warrior(String name, int level) {
        super(name, level);
    }

    @Override
    public void physicalAttack() {
        System.out.println(name + "使用大刀劈砍，造成物理伤害！");
    }

    @Override
    public void defend() {
        System.out.println(name + "举起盾牌防御，减免50%伤害！");
    }

    @Override
    public void specialSkill() {
        System.out.println(name + "释放技能【狂怒斩】，群体物理伤害！");
    }
}

// 子类2：法师（继承抽象类+实现多个接口）
class Mage extends GameRole implements MagicAttack, Defend {
    public Mage(String name, int level) {
        super(name, level);
    }

    @Override
    public void magicAttack() {
        System.out.println(name + "吟唱火球术，造成魔法伤害！");
    }

    @Override
    public void defend() {
        System.out.println(name + "开启魔法护盾，免疫3次魔法伤害！");
    }

    @Override
    public void specialSkill() {
        System.out.println(name + "释放技能【陨石术】，大范围魔法伤害！");
    }
}

// 测试类
public class AbstractInterfaceCombineDemo {
    public static void main(String[] args) {
        GameRole warrior = new Warrior("亚瑟", 30);
        GameRole mage = new Mage("妲己", 28);

        warrior.showRoleInfo();
        ((Warrior) warrior).physicalAttack(); // 向下转型调用接口方法
        ((Warrior) warrior).defend();
        warrior.specialSkill();

        System.out.println("-------------------");

        mage.showRoleInfo();
        ((Mage) mage).magicAttack(); // 向下转型调用接口方法
        ((Mage) mage).defend();
        mage.specialSkill();
    }
}
```



